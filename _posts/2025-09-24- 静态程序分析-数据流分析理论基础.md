---
title: 数据流分析--数据流分析理论基础
date: 2025-09-24
categories: [静态程序分析, 数据流分析]
tags: [静态程序分析]
order: 105
---

## 关键词

1. Iterative,, Algorith,Another View
2. Partial Order
3. Upper Bound and Lower Bound
4. Lattice, Semilattice, Complete and Product Lattice
5. Data Flow Analysis Framework via Lattice
6. Monotonicity and Fixed Point Theorem

## View Iterative Algorithm in Another Way

Given a CFG (program) with k nodes, the iterative algorithm
updates OUT[n] for every node n in each iteration.

Assume the domain of the values in data flow analysis is V,
then we can define a k-tuple
as an element of set (V1 × V2 … × Vk) denoted as Vk

Each iteration can be considered as taking an action to map
an element of Vk to a new element of Vk
, through applying
the transfer functions and control-flow handing, abstracted
as a function F: Vk → Vk

Then the algorithm outputs a series of k-tuples iteratively
until a k-tuple is the same as the last one in two consecutive
iterations

> X is a fixed point of F if F(X) = X

## Partial Order

![PartialOrder](../assets/img/静态程序分析/PartialOrder.png)

## Upper abd Lower Bounds

![UpperLowerBound](../assets/img/静态程序分析/UpperAndLowerBound.png)

![UpperLowerBound2](../assets/img/静态程序分析/UpperLowerBounds2.png)

### Some Properties

* not every poset has lub or glb

* But if a poset has lub or glb it will be unique

> 通过反对称性可证

## Lattice

A poset (V, ≤) is a lattice if every pair of elements in V has both a lub and a glb.

## Semilattice

if only lub exists,then P is called a join semilattice.

if only glb exists,then P is called a meet semilattice.

## Complete Lattice

A poset (V, ≤) is a complete lattice if every subset of V has both a lub and a glb.

Every complete lattice P has a greatest element (denoted as ⊤) and a least element (denoted as ⊥).

Every finite lattice is a complete lattice.

> 程序分析关注的通常是有穷的complete lattice.

## Product Lattice

![ProductLattice](../assets/img/静态程序分析/ProductLattice.png)

* A Product lattice is a lattice.

* if a product lattice L is a prouct of complete lattices, then L is alse complete.

## Data Flow Analysis Framework via Lattice

A data flow analysis framework (D, L, F) consists of:

* D: a direction of data flow: forwards or backwards

* L: a lattice including domain of the values V and a
meet ⊓ or join ⊔ operator

* F: a family of transfer functions from V to V

Data flow analysis can be seen as iteratively applying transfer
functions and meet/join operations on the values of a lattice.

## Monotonicity and Fixed Point Theorem

**Monotonicity**: onotonicity
A function f: L → L (L is a lattice) is monotonic if ∀x, y ∈ L,
x ⊑ y ⟹ f(x) ⊑ f(y)

**Fixed Point Theorem**: Given a complete lattice (L, ⊑), if
(1) f: L → L is monotonic and (2) L is finite,then

the least fixed point of f can be found by iterating
f(⊥), f(f(⊥)), …, fk(⊥) until a fixed point is reached

the greatest fixed point of f can be found by iterating
f(⊤), f(f(⊤)), …, fk(⊤) until a fixed point is reached.

```text
Proof:
By the definition of ⊥ and f: L → L, we have

⊥ ⊑ f(⊥)

As f is monotonic, we have
f(⊥) ⊑ f(f(⊥)) = f2(⊥)

By repeatedly applying f, we have an ascending chain

⊥ ⊑ f(⊥) ⊑ f2(⊥) ⊑ … ⊑ fi
(⊥)

As L is finite (its height is H), the values are bounded among

⊥ , f(⊥) , f2(⊥) … fH(⊥)

When i > H, by pigeonhole principle, there exists k and j that

fk(⊥) = fj(⊥) (assume k < j ≤ H+1)

Further as fk(⊥) ⊑ … ⊑ fj
(⊥) (monotonicity of f), we have
fFix = fk(⊥) = fk+1(⊥)=...fj(⊥)(proof by contradiction)

Thus, the fixed point exists.
```

Least Fixed Point proof

```text
Proof:
Assume we have another fixed point x, i.e., x = f(x)

By the definition of ⊥, we have ⊥ ⊑ x

Induction begins:
As f is monotonic, we have
f(⊥) ⊑ f(x)
Assume fi(⊥) ⊑ fi(x), as f is monotonic, we have
fi+1(⊥) ⊑ fi+1(x)

Thus by induction, we have
fi(⊥) ⊑ fi(x)

Thus fi(⊥) ⊑ fi(x) = x (as x is a fixed point regardless of i),
then we have
fFix = fk(⊥) ⊑ fk(x) = x

Thus the fixed point is the least.
```
